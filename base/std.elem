.# std.elem
.# the element standard library

{`W}:using; .# Import variables from a module into the global scope

{:zworkingdirz,
  ""2MZ :workingdirzz;  .# Save the current working dir
  ""3MZ                 .# Reset the working dir
  import "load"         .# Load load.elem
  workingdirzz 3 MZ     .# Change the working dir back
}:reload;

.#? load S\n  Load a script (same as import)
{`(".elem"+G~)}:load:import;

.###################################
.#		         CONTROL             #
.###################################
.#NOTE Variable inside control functions have a "zz" at the end to avoid name conflicts

.#? if (B) E E\n  if statement:\n  if (bool value) {\n    then\n  } {\n    else\n  }
{```({ifstmtcondzB ifstmtthenz ifstmtelsez,
  {ifstmtelsez} {ifstmtthenz} ifstmtcondz?
})}:if;

.#? B then E\n  evaluates E if B is true
{`({}@@\?)}:then;

.#? dowhile E E\n  evaluates E1 as long as E2 is true\n  always evaluates at least once
{``({dowhilecondz dowhileloopz, {dowhileloopz dowhilecondz}W})}:dowhile;

.#? while E E\n  evaluates E1 as long as E2 is true
{``({whilecondz whileloopz,
  {}
  {{whileloopz whilecondz}W}
  whilecondz?
})}:while;

.#? for S|C L E\n  for loop\n  for "varname" [list] {\n    expressions\n  }
{```({forloopcz forlooplistz forloopblkz,
  "forlooplistz#{:$forloopcz forloopblkz}"~
})}:for;

.#? repeat N E\n  repeat statement:\n  repeat N {\n    expressions\n  }
{``(\%)}:repeat;

.#? A print\n  convert to string a print to console
{.P}:print;

.#? A println\n  convert to string and print to console on its own line
{P'\n'+.P}:println;

.#? try EE\n  evaluate the first block, if error, then evaluate the second block
{``({.K})}:try;

.#? SB conderr\n  throw error message if condition is true
{conderrstrz conderrcondz, {} {conderrstrz.D} conderrcondz?}:conderr;

.{? attr S
  attr getter/setter macro
  creates getters for each variable in the string S
  creates setters for each variable in the form setvarname
  each variable must be whitespace separated
.}
.# {`([1|" "| _ER, {v n, "{1I$(nV)I}:$v;"}]#{_~};)}:attr;
{`({:varnamesz fieldindexzz,
  "[a-z]+"&:varnameszz;
  0:n;
  1:fieldindexzz;

  for "v" varnameszz {
    .# getter
    "{$fieldindexzzM>}:$v;"~

    .# setter
    "{$fieldindexzzM<}:set$v;"~
    fieldindexzzB:fieldindexzz;
  };
})}:attr;


.#? nil\n  represents nothing
{@nilmodule,
  {"<nil>"}:show;
} [0] nilmodule MO:nil;
{nil=}:isnil;

.# Number
.#? N negate\n  negate n
{!}:negate;

.# N e N\n  creates a number using scientific notation\n  5e3 => 5000\n  1.24e4 => 12400.0
{`(10\^*)}:e;

.#? E assert L\n  Evaluates E as a list, throws an error if [E~] != L
{`({blkE expectedL,
  if ([blk] expected=) {
	  .# Do nothing
	} {
    .# Throw an error message about the assertation
	  ["assert " "blk".Z " = " expectedP  "\n\trecieved: " [blk]P]SP.D
	}
})}:assert;

.###################################
.#		  STACK MANIPULATION         #
.###################################

.# 2 copy => copy the top two elements
.# 3 index => duplicate the item in the 3rd index
{.;}:clear;				.#? clear\n  clear the stack
{.A}:listall;			.#? listall\n  dump the entire stack into a list
{~}:dump;					.#? dump\n  dump a list to the stack
{;}:pop;					.#? pop\n  discard the item on the top of the stack
{_}:dup;					.#? dup\n  duplicate the item on the top of that stack
{\_@_@\}:duptwo;	.#? duptwo\n  duplicate the top two items of the stack
{\}:exch;					.#? exch\n  swap the top two elements of the stack
{\}:swap;					.#? swap\n  swap the top two elements of the stack
{'`\L~}:wait;			.#? wait\n  the next item on the stack will be pushed back n times

{.A{t,tV:t;~t}~}:back; .#? back\n  bring the item on the back of the stack to the top
{:t,.A_E:t;~t}:count; .#? count\n  counts the number of items on the stack

.###################################
.#		      	 TYPES               #
.###################################

{.]}:int;					  .#? A int\n  cast to an int
{Md}:double;				.#? A double\n  cast to an double
{Z}:bignum;		      .#? A bignum\n  cast to an bignum
{P}:string;			    .#? A string\n  cast to an string
{.'}:char;          .#? A char\n  cast to an char
{.T}:typeof;				.#? A typeof\n  return the character representation of the type


.#? AC isa\n  returns true if the item's type matches the input character
{itemA typeC,
	[
	  T type'A=.? .# Any
	  {"DFN"item.TN(-1)=!} type'N=.? .# Number is num or bignum
	  {"SL"item.TN(-1)=!} type'L=.? .# Number is a string or list => list
	  type item.T = .# Normal Check
	].S
}:isa;


.###################################
.#		       CHARACTER             #
.###################################

.#? C islower\n  tests if a character is lowercase
{_'`>\'{<&}:islower;

.#? C isupper\n  tests if a character is uppercase
{_'@>\'[<&}:isupper;

.#? C toupper\n  converts a character to uppercase
{cC,c!c_isupper?}:toupper;

.#? C tolower\n  converts a character to lowercase
{cC,c!c_islower?}:tolower;

.#? C swapcase\n  swaps the case of a character
{cC,c!}:swapcase;

.#? C isdigit\n  tests if a character is a digit
{ _'0.>\'9.<&}:isdigit;

.#? S spechar\n  converts the name of a special character into the corresponding special character
{a,"\"\\{$a}\""~0I}:spechar;

.#? specialchars\n  print a list of all the special characters currently loaded
{
  "name          unicode  char" println
  "base/charmap.txt" opencsv #{
    .# Get only the name and the unicode
    0I" "|[0 1]I~ {a b,
      aP '  14 strrightpad print
      b ' 9 strrightpad print
      a spechar println
    }~ 0
  };
}:specialchars;

.###################################
.#		      	 STRING              #
.###################################

{l s, [l, s+]B;l(-1)IAKS}:join;         .#? L S|C join\n  join a list of strings with another string or char
{t:z, t 0:t; # {zBi9%:z+}}:encrypt;			.#? S encrypt\n	 basic string encryption
{t:z, t 0:t; # {zBi9%:z-}}:decrypt;			.#? S decrypt\n	 basic string decryption
{_{isdigit}I=}:alldigits;               .#? S alldigits\n  tests if all chars in a string are digits
{_{}{~}@isnum?}:parseifnum;             .#? S parseifnum\n  if the str is a valid number, parse it; otherwise leave it as a string
{"^\\s+|\\s+$" |S}:trim;                .#? S trim\n  remove whitespace from start and end of string
{dlmS, G "\n"| {""=!}I #{dlm|} #{#.!}}:readdlm;  .#? SS readdlm\n  open a file, split into lines, split each line using dlm
{"," readdlm}:opencsv;                  .#? S opencsv\n  opens and parses a csv file into a matrix
{\_@|S=!}:strcontains;									.#? SS strcontains\n	tests if S1 contains S2
{"\n"|}:lines;                          .#? S lines\n  splits the string into a list of lines
{w, data.words {w^} .$ V\;}:sc;         .#? S sc\n  returns the closet english word to the input

.#? SCI strleftpad\n  left pad string S so it is at least length I using char C
{strS padC lenI, str.E len\- {pad\K}\%}:strleftpad;

.#? SCI strrightpad\n  right pad string S so it is at least length I using char C
{strS padC lenI, str.E len\- {padK}\%}:strrightpad;

.#? SSS replace\n  find and replace\n  <find> <replace> <str> replace
{find replace strS,
	str findP | # {replace+} S {B;}replacePE%
}:replace;

.#? S isnum\n  returns true if the string is a valid number
{
  _alldigits\                   .# The str contains all digits
  _"\\."|S_@EV\E=\ alldigits&   .# The str contains only one decimal, other chars are digits
  |                             .# str is a number is either of the conditions is met
}:isnum;

.#? SS levdist\n levenshtein distance between two strings
{aS bS, a.E b.E levdistrec}:levdist;

.# string 1, length of string 1, string 2, length of string 2
{sS slenI tS tlenI : cost,

  .# Base case (Empty strings)
  if (tlen 0= slen0= |) {
    if (tlen 0=) {
      slen
    } {
      tlen
    }
  }
  .# else
  {
    .# test if last chars of strings match
    if (s(slenV)I t(tlenV)I =) {
      0:cost;
    } {
      1:cost;
    }

    .# return min of (del char from s,
    .#  del char from t, delchar from both)
    [
      s slenV t tlen  levdistrec B
      s slen  t tlenV levdistrec B
      s slenV t tlenV levdistrec cost+
    ]min
  }

}:levdistrec;

.#? S tocamel\n  convert a string with underscores to camel case
{str,
  for 'c ['a'z,] {
    "_$c" c!P str replace :str;
  };
  str
}:tocamel;

.###################################
.#		      	FILE IO              #
.###################################

{G}:read;
{G"\n"|}:readlines;



.###################################
.#		      	  LIST               #
.###################################

{A}:list;							.#? L list\n wraps the item on the top of the stack in a list
{!}:reverse;					.#? L reverse\n  reverses a list
{E}:length;						.#? L length\n  returns the length of a list
{S}:sum;							.#? L sim\n  sums a list
{I}:filter;						.#? LE filter\n  filters a list
{\N(-1)=!}:in;				.#? AL in\n  tests whether or not item `a` is in list `l`
{N(-1)=!}:ni; 				.#? LA ni\n  tests whether or not item `a` is in list `l`
{L}:lrepeat;					.#? AI lrepeat\n creates an list of length `i` filled with `a`
{$}:sort:slg;					.#? L sort\n  sorts a list least to greatest
{$!}:sgl;							.#? L sgl\n  sorts a list greatest to least
{AKR}:range;					.#? NN range\n  generates a range from n1 to n2
{lLiNeA,l i:(e)}:put;	.#? LNA put\n  places the item `a` in the list `l` at index `n`
{[]{.QK}@%}:randset;	.#? I randset\n  generate a set of random nums (0 to 1) of length i
{_EQI}:randchoice;		.#? L randchoice (or rc)\n  chooses a random element from the list
{!{K}U}:flatten;			.#? L flatten\n  flattens the list by a single dimension
{B\K}:roll;      			.#? L roll\n  move the last element to the front
{_@K\K}:surround;     .#? LA surround\n  append A to the front and back of L
{p q e, [p q, e]}:zw;	.#? LLE zw\n  zip with
{\.EV@L#QI}:rpick;    .#? LI rpick\n  pick N random items from L

.#? L<L> matstr\n  print a list of lists in matrix format
{
  [1|~,                 .# Transpose
    .A_#{PE}maxBB	      .# Calculate the maximum print width
    #{\P\>}             .# Pad each entry with spaces on the left
  ][1|~,                .# Transpose
    .AS                 .# Combine strings
  ]'\n'join             .# Sepeaate lines
}:matstr;

{aL bL, [a,,b\N(-1)=]}:setminus;  .#? LL setminus\n removes an item from the first list if it is in the second
{aL bL,[a,,b\N(-1)=!]}:intersect; .#? LL intersect\n creates a new list from the intersection of the input lists
{lL,[0]lERB;K}:irange;	          .#? L irange\n generates a range of indices for the list (use with for loop)

.#? <LLE> permusing\n  permutes elements of two lists and applies an expression to each
{la lb ex, [la lb laEL,\#{ex}]}:permusing:pu;

.#? <LII> swapitems\n  swap two elements in a list given their indices
{listL iD jD : tmp,
	list i I : tmp;
	list j I  list i D
	tmp list j D
  list
}:swapitems;

.#? <L> shuffle\n  shuffle a list
.#{.E{.EVQB|!K!}\_+%}:shuffle; .# Golfed; slower
{listL,
 .#swap 2 rand items..      len(list)*2 times
	{list _E_Q\Q swapitems : list;}  list E2*%
	list .# return the list
}:shuffle;

.#? NNN linspace\n  create a uniform range from n1 to n2 with n3 steps\n  (also see intspace)
{a b nums,
  {[a b a-numsV/a+ b,]}
  a numsL .# a=b, return nums a's
  a b=?

  .# If the length is not equal to nums, add b to the end
  _Enums={bK}{}@?
}:linspace;

.#? III intspace\n create a range from a to b consisting of c ints\n  (also see linspace)
{a b l, [a b l linspace,.]]}:intspace;

.#? L remdups\n removes duplicates in a list
{l:set,
  []:set;

  l#{i,
    .# If the element is not already in the set, add it
    {}{
       set [i] K:set;
    } set i N(-1)= ?
    i
  };

  set
}:remdups;

.#? L<N> digitstonum\n  convert a list of numbers into a number
{lL : total multip,
  1:multip;
  l!#{
    multip* total+:total;
    multip 10 *:multip
  };
  total
}:digitstonum;

{l c : out,[]:out; l {B_ {AKfalse} {outK;true} @c?}W out}:takewhile:tw;
{e,{e=}tw}:takewhileeq:twe;

.###################################
.#		 BOOLEANS / COMPARISONS      #
.###################################

T:true;							.# true literal
F:false;						.# false literal
{`!}:not;						.#? not\n  logical NOT\n  (infix)
{`&}:and;						.#? and\n  logical AND\n  (infix)
{`|}:or;						.#? or\n  logical OR\n  (infix)
{"unimplemented".P}:xor;							.#? xor\n  logical XOR\n  (infix)

.# Operators
{.>}:geq; 			.#? <NN|CC|SS> leq (or \{leq})\n  \{leq} operator
{.<}:leq; 			.#? <NN|CC|SS> geq (or \{geq})\n  \{geq} operator
{=!}:ne;				.#? <NN|CC|SS> ne (or \{ne})\n  \{ne} operator

.# List conditionals
{{&}U}:allt;		.#? <L> allt\n  true if all elements in list are true
{{|}U!}:allf;	.#? <L> allf\n  true if all elements in list are false
{\_@IE\E=}:all; .#? <LE> all\n  tests if all elements of the list meet the condition
{IE0>}:any; 		.#? <LE> any\n  returns true of any elements satisfy the predicate


.###################################
.#		   Bitwise Operators         #
.###################################

.#? N unbit\n  takes a list of bits and converts it to a decimal
{2 10 H}:unbit;

.#? N bits\n  takes a positive number and returns its bits as a list
{10 2 H}:bits;

.#? L<I> N bleftpad\n  append 0s to the left end of L until L is length N
{>}:blpad;


.###################################
.#		   ADDITIONAL FILES          #
.###################################

import "base/math"
import "base/docs"

.# Modules
import "base/regex"
import "base/dict"
import "base/matrix"
import "base/frac"
import "base/date"
import "base/demo"
import "base/stack"
import "base/colors"
import "base/set"
import "base/complex"
import "base/queue"
import "base/stack"
import "base/plot"
import "base/files"
import "base/dataframe"
import "base/dialog"
import "base/dataframe"
import "base/golf"

import "base/data"




.###################################
.#		    DEFAULT VARIABLES        #
.###################################

[]		:emptyset;
{2^}	:square;
{3^}	:cube;
[256,V.']:ascii;

1			 :a;
2			 :b;
3			 :c;
10		 :d;
100		 :h;
{.]}	 :i; .#? A i\n  cast to int
1000	 :k;
[]		 :l;
.#m (matrix module)
"\n"   :n;
{VR0\K}:r; .#? N r\n  range from 0 to (1-n)
1!		 :w;
0			 :x;
0			 :y;

.#z (infix frac constructor)

.# Stopwatch
{M$:timeitstart;}:timeitstart;
{["timeit: "M$timeitstart-3E/"s\n"]S.P {M$:timeitstart;}:timeitstart;}:timeitend;
{{M$:timeitstart;}:timeitstart;}:timeitclear;


" |":spacebar;

{`({a b, a#tolower:a; b#tolower:b; a"jasmine"= a"nick"=| b"jasmine"= b"nick"=| &})}:heart;

{:z,#{zB:z3%+}}:scramble;
{:z,#{zB:z3%-}}:descramble;

.# Overwrite bowtie default
9999.' "bowtie" Mk
