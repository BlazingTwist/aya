{,
    .#? sys.iswindows\n  returns true if system is windows
    {:9c"\\"=}:iswindows;

    .# str sys.cd
    {dirname,
        dirname
        .# If it is a string, conv to path
        dirname :T ::str = { path! } ?
        P 3MZ
    }:cd;

    .#? sys.mkdir S\n  create a new directory
    {dir::str,
        dir 5MZ
    }:mkdir;

}:sys;

{,

    ::path:type;

    .# List of directories
    []:dirs;

    .# Create a new path (accepts relative or abs paths)
    {dir::str,
        .# If direct path
        dir path.isabs ! {
            path.workingP "/"+ dir + :dir;
        } ?
        {, dir path.split path.fixhome path.clean :dirs} path MO
    }:new;

    .# path path.isfile\n  Return true if path is file (last item in the path contains a ".")
    {p::path,
        p.dirs.[:1] "." N :1 =! \;
    }:isfile;

    .#? str path path.add\n  append file or dir to path, if path is file, don't change
    {dir::str self,
        .# Modify a copy of this path
        self _ :self; ;
        .# Can only join if the path is not a file
        self.isfile ! {
        self.dirs dir path.split K
            path.clean ;
        } ?
        self
    }:add;
    {\.add}:radd;


   .# String representation of the path
    {self,
        self.dirs :9c * path.root :9c + \+
        self.isfile ! {:9c +} ?
    }:str:repr;


    .#? path path V\n  Go up a directory
    {self,
        self.dirs B;; self
    }:dec;



    .# Constants

    .# Root dir name
    sys.iswindows {
        "C:"
    } {
        ""
    } .? :root;

    .# Working dir
    {""2MZ path!}:working;


    .##########################
    .# PRIVATE HELPER METHODS #
    .##########################

    .# Regular expression used for splitting path strings
    .# If :9c is "\", return escaped "\\" otherwise return :9c
    sys.iswindows {:9c_+} {:9c} .? :filesplit;

    .# Split a string using the system file sepatator and remove empy dir names
    {dir::str,
        .# Split using system sep
        dir A :# {path.filesplit |~}
        .# Split using "/"
        :# {"/"|~}
        .# Remove empties
        [""] :|
    }:split;


    .# If the path list contains a "~"
    .#   find the last "~" and take all directories after it
    {dirs::list,
        dirs U "~" N    .# Reverse and find the first ~ (aka the last ~)

        .# Does the path contain a "~" ?
        _:1=! {
            .< U .# Take all directories before the "~" and reverse

            .# Append the home dir to the front
            path.home.dirs _\;  .# Copy home.dirs
            \K                  .# Append to front
        } {
            ;U .# Pop the -1 and put the list back
        } .?
    }:fixhome;


    .# Return true of the given string is an absolute path
    {p::str,
        p "/" N 0 = \;
        p path.root :9c + N 0 = \;
        p path.root "/" + N 0 = \;
        | |
    }:isabs;

    .# Remove all ".." by traversing the directories
    {dirs::list : i(0),
        .# Remove root and self refs (".")
        dirs [path.root "."] :| ;

        .# If there is a ".." remove the dir before it
        {{
            .# If there is a "..",
            dirs.[iB] ".." = {
                .# Remove the ".." and the dir before it
                dirs [i iB] .-;
                .# Then move the index back 2
                i2-:i;
            } ?
            ::iB
            i dirs EV <
        }W}
        .# If the above code has an error, the path is invalid
        {; []:dirs;} .K
        dirs
    }:clean;

}:path;


{, ""7MZ path.split :dirs} path MO path.:home;
{, ""2MZ path.split :dirs} path MO path.:dfltworking;


.#########
.# TESTS #
.#########

import ::test

`~ {:ts,

  "path" testset! :ts;

  {"/a/b/c" path!.dirs} [["a""b""c"]] ts+
  {"/a/b/c/.." path!.dirs} [["a""b"]] ts+
  {"/a/b/c" path! ".." + .dirs} [["a""b"]] ts+
  {"/a/b/c" path! V .dirs} [["a""b"]] ts+
  {"~/a" path!P} [path.homeP "a" + :9c +] ts+

  ts aya.addtest

}




