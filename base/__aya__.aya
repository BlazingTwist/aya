.# This file is a part of aya: https://github.com/nick-paul/aya-lang

.# __aya__
.# Defines the __aya__ namespace and keywords

.# NOTE: 12 letter variables ending in the letter 'z' are reserved for use in
.#       standard library. Such variables are used below.



{, .# begin __aya__ namespace

[
  "__aya__"  .# This file
]:imported;

""2MZ "base" :9c + + :basedir;
""2MZ :homedir;

.#? S __aya__.alterprompt\n  change the prompt text
{1MZ}:alterprompt;

{,}:interpreter;

.# import name; import dir name
{importname__ importdirn__,

    .# True if the file is not imported
    __aya__.imported importname__ N\; :-1 =

    .# If condition is true
    { .# File not already imported, load it

        .# Add the name to the list
        importname__ __aya__.imported .B;

        { .# try
            .# Load the file
            importdirn__ importname__ + ".aya" + G ~
        } {e, .# catch
            .# Remove the file from imported list
            __aya__.imported importname__ N .- ;
            "Error importing '$(importname__)':\n\t$e" .D
        } .K

    }

    .# If condition is false
    { .# File already imported
      .# do nothing
    }
    .?

}:importfrmdir;


.# importbase uses the home dir instead of the
.# base dir
{
  __aya__.basedir __aya__.importfrmdir
}:importbase;


.# importfile uses the home dir instead of the
.# base dir
{
  __aya__.homedir __aya__.importfrmdir
}:importfile;

{importname__,
    .# Does the name contain a file sep? (:9c)
    .# :9c $ "\\"= {;"\\\\"} ? returns an escaped "\" -> "\\" if windows
    importname__ $ (:9c $ "\\"= {;"\\\\"} ?) | #{"/"|} .F =

    { .# No file sep, import from base
        importname__ __aya__.importbase
    }

    { .# input contains a file sep
        importname__ __aya__.importfile
    }

    .?
}:import;


{
    [] __aya__.:imported;
}:resetimports;

{,
    "M!" :__fact__
    "Ms" :__sin__
    "Mc" :__cos__
    "Mt" :__tan__
    "MS" :__asin__
    "MC" :__acos__
    "MT" :__atan__
    "ML" :__log__
    "Ml" :__ln__
    "Me" :__exp__
    "Md" :__float__
    "Mq" :__sqrt__
}:mathoverload

}:__aya__;





.#######################
.# DEFINE __aya__ KEYWORDS #
.#######################



.# ------
.# IMPORT
.# ------

.#? import library\n  import a __aya__ file\n  files are only imported once
{`(
    $ :T ::sym = {:C} ?
    .# Split whitespace separated names
    "\s+" | [""] :| #{__aya__.import};
)}:import;




.# ------
.# RELOAD
.# ------

.#? reload\n  reload imported files
{:workingdir__,
    ""2MZ            .# Save the current working dir
    ""3MZ            .# Reset the working dir
    __aya__.imported$\;  .# Copy currently imported files
    __aya__.resetimports .# Clear all imports
    "ayarc.aya" G ~  .# Load __aya__rc
    \ 3 MZ           .# Change the working dir back
    # {__aya__.import};  .# Reimport files
}:reload;




.# ----
.# LOAD
.# ----

.#? load S\n  Load a script
{`(".aya"+G~)}:load;



.# -----
.# USING
.# -----

.#? using dict\n  import variables from a dict into the current scope
{`W}:using;



.# ------
.# STRUCT
.# ------

{``({name::sym members::list : namestr,
    name:C :namestr;
    [
        "{,"

        "  ::$namestr:__type__;"
        "  {"  members :#{:C} " "* "," ++
        "    {, " members :#{[1|:C$]":"*}" "* + "}"+
        "    $namestr MO"
        "  }:__new__;"

        "  {self, [ \"(\""
        "    " members :# {"self."\:C+} " "* +
        """    ")" ] " "* " """ namestr + "!\" +" +
        "  }:__str__:__repr__;"

        "}:$namestr;"
    ]"\n"* ~
})}:struct;





.###########
.# CONTROL #
.###########

.#? if (B) E E\n  if statement:\n  if (bool value) {\n    then\n  } {\n    else\n  }
{```.?}:if;


.#? B then E\n  evaluates E if B is true
{`?}:then;


.#? dowhile E E\n  evaluates E1 as long as E2 is true\n  always evaluates at least once
{``({condition__ loop__,
    {loop__ condition__} W
})}:dowhile;


.#? while E E\n  evaluates E1 as long as E2 is true
{``({condition__ loop__,
    condition__ {
        {loop__ condition__} W
    } ?
})}:while;

.#? A print\n  convert to string a print to console
{.P}:print;


.#? A println\n  convert to string and print to console on its own line
{:P}:println;


.#? getline\n  read input from stdin and return it as a string
{:R}:getline;


.#? SB conderr\n  throw error message if condition is true
{{.D} {;} .?}:conderr;

.#? BS assert\n throw error if bool is false
{\! {.D} {;} .?}:assert;

.#? B where D\n  use variables defined in D in B
.{ Example
    aya> {a, a b *} where {, 2:b } :double
    {a , a 2 * }
    aya> 3 double
    6

   Set constant values in loops.
   Before
    aya> 3R :# {{a, a b *} where {, 10:b "evaluating..":P} ~}
    evaluating..
    evaluating..
    evaluating..
    [ 10 20 30 ]
   After: (note the parenthesis)
    aya> 3R :# ({a, a b *} where {, 10:b "evaluating..":P})
    evaluating..
    [ 10 20 30 ]

   Escape functions with .` and ~ :
    aya> {a, a fn~} where {, double.` :fn} :apply_double
    {a , a {x , x 2 * } ~ }
    aya> 2 apply_double
    4

   Nesting!
    aya> {a, a fn~} where {, {a, a b *} where {, 2:b} :fn} :apply_double
    {a , a {a , a 2 * } ~ }
    aya> 2 apply_double
    4
.}
{`.+}:where;


.#? ::block with ::list\n  evaulate the variables (given by a list of symbols) in the block in the current scope
.{ Example:
    aya> 2:y
    2
    aya> {x, x y *} with [::y] :double
    {x , x 2 * }
    aya> 3 double
    6
.}
{`({:d__,
    .# Create a dictionary of all valies given by the list
    {,}:d__;
    :#{$~\d__:D;};
    .# Substitute the values from the dictionary into the block
    d__ .+
})}:with;


.################
.# import types #
.################

.#"C:/Users/Nick/git/aya-lang/base/" __aya__.:basedir;

import """
types
str
num
char
block
list
test
"""
