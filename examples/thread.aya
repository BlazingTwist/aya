"== Single Task ==" :P

.# Create a single thread and run a task
:{thread.new} :thread_id;

"Created thread with id $(thread_id)" :P

{
    "starting task" :P
    1 1 +
    "finished task" :P
} thread_id :{thread.add_task}

thread_id :{thread.wait_for_result} :result;

"Result is $(result)" :P



.# Create multiple threads with tasks

"== Multiple Tasks ==" :P

[4,{i, {:i^, 300:Z "Task $(i) complete" :P i} }] :tasks;

[tasksE ,; :{thread.new}]:thread_ids;

[tasks thread_ids, {task thread_id,
    task.` thread_id :{thread.add_task}
}];

[thread_ids, :{thread.wait_for_result}] :P

"complete" :P


.# Thread pool
"== Thread Pool ==" :P

[10 ,{i, {:i^, 1000:Z "Task $(i) complete" :P i} }] :tasks;

[4 ,; :{thread.new}]:thread_pool_ids;


[] :threads_with_tasks;
[thread_pool_ids ~] :thread_pool; .# Available


.# Loop until no tasks remain
{
    .# For each thread with a task, check if it is ready,
    .# if it is, get the result and add it back to the pool
    [] :finished_threads;
    threads_with_tasks :# {thread_id : res, 
        thread_id :{thread.has_unfinished_tasks} ! {
            thread_id :{thread.wait_for_result} :res;
            "Got result $res" :P
            thread_id finished_threads .B;
        } ?
    };

    .# Remove finished threads from threads with tasks
    threads_with_tasks finished_threads :| :threads_with_tasks;

    .# Add the finished threads back to the pool
    thread_pool finished_threads J :thread_pool;

   .# Add a task to each thread in the pool
    thread_pool :# {thread_id,
        tasks E 0 > {
            tasks B\; thread_id :{thread.add_task}
            thread_id threads_with_tasks .B;
        } ?
    };

    .# Remove threads with tasks from the pool
    thread_pool threads_with_tasks :| :thread_pool;

    1 :Z

tasks E 0 > } W

.# Wait for all remaining tasks
threads_with_tasks :# {thread_id : res,
    thread_id :{thread.wait_for_result} :res;
    "Got result $res" :P
};

"done" :P
