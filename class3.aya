{,
    {meta : instance,
        {, meta :__meta__; } :instance;

        .# If it has a constructor call it
        instance ::__init__ N \; {
            instance.__init__
        } ?

        .# return the new object
        instance
    }:__new__;


    {self,
        "($(self.__type__:C) 0x$(self M# 10 16 H))"
    }:__repr__;

    ::object:__type__;
    1 :__pushself__;

}:object;

{type::sym super,
    {,
        super:__meta__;
        type:__type__;
        .# copy new
        super.__new__.` :__new__;
        1:__pushself__;
    } type :=
}:extend;

{: extend^ object^,
    {:extend^ object^, ~:S~ object extend;} 1 :`
}:class;

class vec

def vec::__init__ {x y self,
    x self.:x;
    y self.:y;
}

def vec::__repr__ {self,
    "<$(self.x),$(self.y)>"
}

def vec::hypot {self,
    self.x 2 ^ self.y 2 ^ + .^
}

def vec::dims 2


.# OOP Testing

::dog object extend;

def dog::__init__ {name age self,
    name self.:name;
    age  self.:age;
}

def dog::species "Canis familiaris"

def dog::__repr__ {self,
    "$(self.name) is a $(self:T:C) and is $(self.age) years old"
}

def dog::speak {self,
    "$(self.name) says woof!"
}


"Buddy" 9 dog! :buddy;
"Miles" 4 dog! :miles;

::dachshund dog extend;
::poodle dog extend;

"Oscar" 3 dachshund! :oscar;
"Bubs" 3 poodle! :bubs;

{cls : l,
    []:l;
    cls.__type__ l .B;
    {
        .# Move to the next meta
        cls.__meta__:cls
        .# append this type to the list
        .__type__ l .B;
        .# Stop if there is no more metatables
        cls::__meta__ N\;
    } W
    l
}:type_chain;

{ :@ }:isinstance;

bubs  poodle isinstance !{"failed".D}?
bubs  dog    isinstance !{"failed".D}?
bubs  object isinstance !{"failed".D}?
oscar poodle isinstance  {"failed".D}?

bubs {x::poodle, } ~
bubs {x::dog,    } ~
bubs {x::object, } ~

{
    {
        ~PB;V;V; .# literally parse the string from the block...
        \:&.__meta__.__meta__@ :I\; ~
    } 1 :`
}:super;

def poodle::speak {self,
    "poodle speak!" :P
    self super.speak
}

.# TODO: built-in super operator

::person object extend;

def person::__init__ {name age self : person^,
    name self.:name;
    age  self.:age;
    person.counter 1+ person.:counter;
}

def person::counter 0

def person::greet {self,
    "Hi it's $(self.name)"
}

def person::create_anon {cls,
    "Anon" 20 cls!
}

.# static methods still require the cls argument
def person::years_to_months {years cls,
    years 12 *
}



"John" 25 person! :john;
person.create_anon :anon;
3 person.years_to_months ;

::employee person extend;

def employee::__init__ {name age job self,
    name age self super.__init__
    job self.:job;
}

"bob" 30 "salesman" employee! :bob;

def employee::greet {self,
    self super.greet ", I'm a $(self.job)" +
}

{type__::sym members__::list super__ :
    extend__(extend.`)
    cls__,

    type__ super__ extend__ : cls__;

    .# __init__
    {self,
        .# grab all members from the stack
        num_members :A
        .# and assign them to self
        members {self :D} .&;
    } {,
        members__ E :num_members;
        members__   :members;
    } .+ cls__.:__init__;

    .# __str__/__repr__
    .# default string:
    .# ( m1 m2 ... mN ) type!
    {self,
        "( "
        members :# {self \:I \;} " "* +
        " ) " +
        name  +
        "!"+
    } {,
        type__ :C   :name;
        members__ :members;
    } .+ cls__.:__str__;

    cls__.__str__.` cls__.:__repr__;

    cls__
}:_struct_impl;

{ : _struct_impl(_struct_impl.`) object^,
    { : _struct_impl^ , :&.[0]:S~ \.[1]~.*:#{:S~} object _struct_impl } 2 :`
}:structb;
